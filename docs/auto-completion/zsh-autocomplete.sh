#!/usr/bin/env zsh
# Command completion for app
# Generated by Clikt

autoload bashcompinit
bashcompinit

__skip_opt_eq() {
    # this takes advantage of the fact that bash functions can write to local
    # variables in their callers
    (( i = i + 1 ))
    if [[ "${COMP_WORDS[$i]}" == '=' ]]; then
          (( i = i + 1 ))
    fi
}

_app() {
  local i=1
  local in_param=''
  local fixed_arg_names=()
  local vararg_name=''
  local can_parse_options=1

  while [[ ${i} -lt $COMP_CWORD ]]; do
    if [[ ${can_parse_options} -eq 1 ]]; then
      case "${COMP_WORDS[$i]}" in
        --)
          can_parse_options=0
          (( i = i + 1 ));
          continue
          ;;
        --version|--v|-v|-version)
          __skip_opt_eq
          in_param=''
          continue
          ;;
        --generate-completion)
          __skip_opt_eq
          (( i = i + 1 ))
          [[ ${i} -gt COMP_CWORD ]] && in_param='--generate-completion' || in_param=''
          continue
          ;;
        --working-directory-path|--wd)
          __skip_opt_eq
          (( i = i + 1 ))
          [[ ${i} -gt COMP_CWORD ]] && in_param='--working-directory-path' || in_param=''
          continue
          ;;
        --config-file-path)
          __skip_opt_eq
          (( i = i + 1 ))
          [[ ${i} -gt COMP_CWORD ]] && in_param='--config-file-path' || in_param=''
          continue
          ;;
        --db-type)
          __skip_opt_eq
          (( i = i + 1 ))
          [[ ${i} -gt COMP_CWORD ]] && in_param='--db-type' || in_param=''
          continue
          ;;
        --db-uri)
          __skip_opt_eq
          (( i = i + 1 ))
          [[ ${i} -gt COMP_CWORD ]] && in_param='--db-uri' || in_param=''
          continue
          ;;
        --trust-uri)
          __skip_opt_eq
          in_param=''
          continue
          ;;
        --mongo-tmp-path)
          __skip_opt_eq
          (( i = i + 1 ))
          [[ ${i} -gt COMP_CWORD ]] && in_param='--mongo-tmp-path' || in_param=''
          continue
          ;;
        --config)
          __skip_opt_eq
          in_param=''
          continue
          ;;
        -h|--help)
          __skip_opt_eq
          in_param=''
          continue
          ;;
      esac
    fi
    case "${COMP_WORDS[$i]}" in
      update-db)
        _app_update_db $(( i + 1 ))
        return
        ;;
      list)
        _app_list $(( i + 1 ))
        return
        ;;
      mark-script-as-executed)
        _app_mark_script_as_executed $(( i + 1 ))
        return
        ;;
      generate-completion)
        _app_generate_completion $(( i + 1 ))
        return
        ;;
      *)
        (( i = i + 1 ))
        # drop the head of the array
        fixed_arg_names=("${fixed_arg_names[@]:1}")
        ;;
    esac
  done
  local word="${COMP_WORDS[$COMP_CWORD]}"
  if [[ "${word}" =~ ^[-] ]]; then
    COMPREPLY=($(compgen -W '--version --v -v -version --generate-completion --working-directory-path --wd --config-file-path --db-type --db-uri --trust-uri --mongo-tmp-path --config -h --help' -- "${word}"))
    return
  fi

  # We're either at an option's value, or the first remaining fixed size
  # arg, or the vararg if there are no fixed args left
  [[ -z "${in_param}" ]] && in_param=${fixed_arg_names[0]}
  [[ -z "${in_param}" ]] && in_param=${vararg_name}

  case "${in_param}" in
    --version)
      ;;
    --generate-completion)
      ;;
    --working-directory-path)
      ;;
    --config-file-path)
      ;;
    --db-type)
      COMPREPLY=($(compgen -W 'mongo jdbc' -- "${word}"))
      ;;
    --db-uri)
      ;;
    --trust-uri)
      ;;
    --mongo-tmp-path)
      ;;
    --config)
      ;;
    --help)
      ;;
    *)
      COMPREPLY=($(compgen -W 'update-db list mark-script-as-executed generate-completion' -- "${word}"))
      ;;
  esac
}

_app_update_db() {
  local i=$1
  local in_param=''
  local fixed_arg_names=()
  local vararg_name=''
  local can_parse_options=1

  while [[ ${i} -lt $COMP_CWORD ]]; do
    if [[ ${can_parse_options} -eq 1 ]]; then
      case "${COMP_WORDS[$i]}" in
        --)
          can_parse_options=0
          (( i = i + 1 ));
          continue
          ;;
        --path)
          __skip_opt_eq
          (( i = i + 1 ))
          [[ ${i} -gt COMP_CWORD ]] && in_param='--path' || in_param=''
          continue
          ;;
        --identifier-regex)
          __skip_opt_eq
          (( i = i + 1 ))
          [[ ${i} -gt COMP_CWORD ]] && in_param='--identifier-regex' || in_param=''
          continue
          ;;
        --whitelisted-tags)
          __skip_opt_eq
          (( i = i + 1 ))
          [[ ${i} -gt COMP_CWORD ]] && in_param='--whitelisted-tags' || in_param=''
          continue
          ;;
        --blacklisted-tags)
          __skip_opt_eq
          (( i = i + 1 ))
          [[ ${i} -gt COMP_CWORD ]] && in_param='--blacklisted-tags' || in_param=''
          continue
          ;;
        --tags-to-play-again)
          __skip_opt_eq
          (( i = i + 1 ))
          [[ ${i} -gt COMP_CWORD ]] && in_param='--tags-to-play-again' || in_param=''
          continue
          ;;
        --create-tags-from-folder)
          __skip_opt_eq
          in_param=''
          continue
          ;;
        --execution-mode)
          __skip_opt_eq
          (( i = i + 1 ))
          [[ ${i} -gt COMP_CWORD ]] && in_param='--execution-mode' || in_param=''
          continue
          ;;
        --action)
          __skip_opt_eq
          (( i = i + 1 ))
          [[ ${i} -gt COMP_CWORD ]] && in_param='--action' || in_param=''
          continue
          ;;
        --allow-auto-override)
          __skip_opt_eq
          in_param=''
          continue
          ;;
        --verbose)
          __skip_opt_eq
          in_param=''
          continue
          ;;
        --save-db-output)
          __skip_opt_eq
          in_param=''
          continue
          ;;
        --print-db-output)
          __skip_opt_eq
          in_param=''
          continue
          ;;
        --tag)
          __skip_opt_eq
          (( i = i + 1 ))
          [[ ${i} -gt COMP_CWORD ]] && in_param='--tag' || in_param=''
          continue
          ;;
        --rule)
          __skip_opt_eq
          (( i = i + 1 ))
          [[ ${i} -gt COMP_CWORD ]] && in_param='--rule' || in_param=''
          continue
          ;;
        --mongo-shell)
          __skip_opt_eq
          (( i = i + 1 ))
          [[ ${i} -gt COMP_CWORD ]] && in_param='--mongo-shell' || in_param=''
          continue
          ;;
        --porcelain)
          __skip_opt_eq
          in_param=''
          continue
          ;;
        --flags)
          __skip_opt_eq
          (( i = i + 1 ))
          [[ ${i} -gt COMP_CWORD ]] && in_param='--flags' || in_param=''
          continue
          ;;
        -h|--help)
          __skip_opt_eq
          in_param=''
          continue
          ;;
      esac
    fi
    case "${COMP_WORDS[$i]}" in
      *)
        (( i = i + 1 ))
        # drop the head of the array
        fixed_arg_names=("${fixed_arg_names[@]:1}")
        ;;
    esac
  done
  local word="${COMP_WORDS[$COMP_CWORD]}"
  if [[ "${word}" =~ ^[-] ]]; then
    COMPREPLY=($(compgen -W '--path --identifier-regex --whitelisted-tags --blacklisted-tags --tags-to-play-again --create-tags-from-folder --execution-mode --action --allow-auto-override --verbose --save-db-output --print-db-output --tag --rule --mongo-shell --porcelain --flags -h --help' -- "${word}"))
    return
  fi

  # We're either at an option's value, or the first remaining fixed size
  # arg, or the vararg if there are no fixed args left
  [[ -z "${in_param}" ]] && in_param=${fixed_arg_names[0]}
  [[ -z "${in_param}" ]] && in_param=${vararg_name}

  case "${in_param}" in
    --path)
      ;;
    --identifier-regex)
      ;;
    --whitelisted-tags)
      ;;
    --blacklisted-tags)
      ;;
    --tags-to-play-again)
      ;;
    --create-tags-from-folder)
      ;;
    --execution-mode)
      COMPREPLY=($(compgen -W 'NORMAL DRY' -- "${word}"))
      ;;
    --action)
      COMPREPLY=($(compgen -W 'RUN MARK_AS_EXECUTED OVERRIDE_EXECUTED' -- "${word}"))
      ;;
    --allow-auto-override)
      ;;
    --verbose)
      ;;
    --save-db-output)
      ;;
    --print-db-output)
      ;;
    --tag)
      ;;
    --rule)
      COMPREPLY=($(compgen -W 'SameScriptsAsExecutedCheck' -- "${word}"))
      ;;
    --mongo-shell)
      COMPREPLY=($(compgen -W 'mongo mongosh' -- "${word}"))
      ;;
    --porcelain)
      ;;
    --flags)
      ;;
    --help)
      ;;
  esac
}

_app_list() {
  local i=$1
  local in_param=''
  local fixed_arg_names=()
  local vararg_name=''
  local can_parse_options=1

  while [[ ${i} -lt $COMP_CWORD ]]; do
    if [[ ${can_parse_options} -eq 1 ]]; then
      case "${COMP_WORDS[$i]}" in
        --)
          can_parse_options=0
          (( i = i + 1 ));
          continue
          ;;
        -h|--help)
          __skip_opt_eq
          in_param=''
          continue
          ;;
      esac
    fi
    case "${COMP_WORDS[$i]}" in
      *)
        (( i = i + 1 ))
        # drop the head of the array
        fixed_arg_names=("${fixed_arg_names[@]:1}")
        ;;
    esac
  done
  local word="${COMP_WORDS[$COMP_CWORD]}"
  if [[ "${word}" =~ ^[-] ]]; then
    COMPREPLY=($(compgen -W '-h --help' -- "${word}"))
    return
  fi

  # We're either at an option's value, or the first remaining fixed size
  # arg, or the vararg if there are no fixed args left
  [[ -z "${in_param}" ]] && in_param=${fixed_arg_names[0]}
  [[ -z "${in_param}" ]] && in_param=${vararg_name}

  case "${in_param}" in
    --help)
      ;;
  esac
}

_app_mark_script_as_executed() {
  local i=$1
  local in_param=''
  local fixed_arg_names=()
  local vararg_name=''
  local can_parse_options=1

  while [[ ${i} -lt $COMP_CWORD ]]; do
    if [[ ${can_parse_options} -eq 1 ]]; then
      case "${COMP_WORDS[$i]}" in
        --)
          can_parse_options=0
          (( i = i + 1 ));
          continue
          ;;
        --path)
          __skip_opt_eq
          (( i = i + 1 ))
          [[ ${i} -gt COMP_CWORD ]] && in_param='--path' || in_param=''
          continue
          ;;
        --verbose)
          __skip_opt_eq
          in_param=''
          continue
          ;;
        -h|--help)
          __skip_opt_eq
          in_param=''
          continue
          ;;
      esac
    fi
    case "${COMP_WORDS[$i]}" in
      *)
        (( i = i + 1 ))
        # drop the head of the array
        fixed_arg_names=("${fixed_arg_names[@]:1}")
        ;;
    esac
  done
  local word="${COMP_WORDS[$COMP_CWORD]}"
  if [[ "${word}" =~ ^[-] ]]; then
    COMPREPLY=($(compgen -W '--path --verbose -h --help' -- "${word}"))
    return
  fi

  # We're either at an option's value, or the first remaining fixed size
  # arg, or the vararg if there are no fixed args left
  [[ -z "${in_param}" ]] && in_param=${fixed_arg_names[0]}
  [[ -z "${in_param}" ]] && in_param=${vararg_name}

  case "${in_param}" in
    --path)
      ;;
    --verbose)
      ;;
    --help)
      ;;
  esac
}

_app_generate_completion() {
  local i=$1
  local in_param=''
  local fixed_arg_names=('SHELL')
  local vararg_name=''
  local can_parse_options=1

  while [[ ${i} -lt $COMP_CWORD ]]; do
    if [[ ${can_parse_options} -eq 1 ]]; then
      case "${COMP_WORDS[$i]}" in
        --)
          can_parse_options=0
          (( i = i + 1 ));
          continue
          ;;
        -h|--help)
          __skip_opt_eq
          in_param=''
          continue
          ;;
      esac
    fi
    case "${COMP_WORDS[$i]}" in
      *)
        (( i = i + 1 ))
        # drop the head of the array
        fixed_arg_names=("${fixed_arg_names[@]:1}")
        ;;
    esac
  done
  local word="${COMP_WORDS[$COMP_CWORD]}"
  if [[ "${word}" =~ ^[-] ]]; then
    COMPREPLY=($(compgen -W '-h --help' -- "${word}"))
    return
  fi

  # We're either at an option's value, or the first remaining fixed size
  # arg, or the vararg if there are no fixed args left
  [[ -z "${in_param}" ]] && in_param=${fixed_arg_names[0]}
  [[ -z "${in_param}" ]] && in_param=${vararg_name}

  case "${in_param}" in
    --help)
      ;;
    SHELL)
      COMPREPLY=($(compgen -W 'bash zsh fish' -- "${word}"))
      ;;
  esac
}

complete -F _app app
